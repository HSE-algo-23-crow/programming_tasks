# Постановка задачи
Имеется неориентированный взвешенный граф. Назовем остовным деревом подграф, содержащий все вершины исходного графа, который является деревом. И задача состоит в том, чтобы найти такое остовное дерево, сумма рёбер которого минимальна.
# Алгоритм Прима
## Описание алгоритма
Алгоритм Прима — это жадный алгоритм для нахождения минимального остовного дерева (МОД) в связном, взвешенном графе. Минимальное остовное дерево — это подмножество ребер графа, которое соединяет все вершины вместе, не образуя циклов, при этом имея минимальную возможную сумму весов.

Порядок действий:

- Выбирается произвольная стартовая вершина.
- Помечаем эту вершину как включенную в минимальное остовное дерево.
- Устанавливаем веса всех рёбер, соединяющих выбранную вершину с остальными вершинами, как текущие минимальные значения.

- На каждом шаге выбирается ребро с минимальным весом из множества рёбер, которые соединяют вершины, уже включенные в остовное дерево, с вершинами, ещё не включенными в него.

- Выбранное ребро добавляется в минимальное остовное дерево.
- Новая вершина, соединённая этим ребром, включается в остовное дерево.
- Обновляются веса рёбер, соединяющих новую вершину с остальными вершинами, ещё не включенными в остовное дерево.

- Шаги 2 и 3 повторяются до тех пор, пока все вершины не будут включены в минимальное остовное дерево.

### Входные данные:
Граф G (V, E), где V - множество вершин, E - множество ребер.

Вес каждого ребра  w(u,v), где u и v — вершины, соединенные этим ребром.

На вход в программу граф вводится в виде матрицы с действительными числами.

### Выходные данные:
Минимальное остовное дерево, представляющее собой подмножество рёбер E', такого, что |E'| = |V|-1 и сумма весов ребер в E' минимальна.

Вывод в виде матрицы с подмножеством ребер.
### Области допустимых значений:
- Граф должен быть связным
- Граф должен быть взвешенным
- Веса всех ребер должны быть неотрицательными
## Пример выполнения алгоритма

Пусть дан граф, как на рисунке ниже. В скобках указаны веса ребер.

![image](https://github.com/HSE-algo-23-crow/programming_tasks/assets/113132061/64db7409-e19c-4f14-a5b9-8503d270595d)


1. Выберем произвольную вершину. Пусть это будет вершина номер 3. Ей инцидентны ребра (с неиспользованными вершинами): b(3), c(1), d(4). Ребро с наименьшим весом — c. Включим его и инцидентную ему вершину в дерево.

2. Вершинам 1 и 3 инцидентны ребра (с неиспользованными вершинами): a(5), b(3), d(4), f(2). Ребро с наименьшим весом — f. Включим его и инцидентную ему вершину в дерево

![image](https://github.com/HSE-algo-23-crow/programming_tasks/assets/113132061/28924de2-c3bd-4dd7-879c-ea203830ebeb)

3. Вершинам 1, 3 и 5 инцидентны ребра (с неиспользованными вершинами): a(5), b(3), d(4), e(11). Ребро с наименьшим весом — b. Включим его и инцидентную ему вершину в дерево.

![image](https://github.com/HSE-algo-23-crow/programming_tasks/assets/113132061/635ecf12-49b1-499b-964a-437e5b54a4cd)


4. Вершинам 1, 2, 3 и 5 инцидентны ребра (с неиспользованными вершинами): d(4) и e(11). Ребро с наименьшим весом — d. Включим его и инцидентную ему вершину в дерево.

![image](https://github.com/HSE-algo-23-crow/programming_tasks/assets/113132061/d684a6e0-c670-4083-b7ea-b8e158b609dd)

Все вершины графа включены в дерево. Работа алгоритма завершена.
